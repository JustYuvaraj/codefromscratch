import React, { useState, useEffect, useRef, useCallback } from 'react';
import { EditorState, StateField, StateEffect, Compartment } from '@codemirror/state';
import { EditorView, keymap, lineNumbers, Decoration } from '@codemirror/view';
import { defaultKeymap, history, indentWithTab } from '@codemirror/commands';
import { javascript } from '@codemirror/lang-javascript';
import { oneDark } from '@codemirror/theme-one-dark';

// --- Interpreter with ES6+ Support and Nested Scopes ---
// This class parses an Abstract Syntax Tree (AST) generated by Babel
// and executes the code step-by-step, recording the state at each point.
class Interpreter {
    constructor(ast) {
        this.ast = ast;
        // The scopes stack keeps track of all variables in the current execution context.
        this.scopes = [{ type: 'global', name: 'Global', variables: new Map() }];
        // The callStack tracks active function calls.
        this.callStack = [];
        // The trace is the final output, a log of every execution step.
        this.trace = [];
        // The output array stores everything logged to the custom console.
        this.output = []; // Now stores objects: { id: string, text: string, step: number }
        this.returnValue = undefined;
        this.consoleLineIdCounter = 0; // Unique ID for console lines

        // Pre-define common global objects and functions like console, JSON, and Math.
        const globalVariables = this.scopes[0].variables;
        globalVariables.set('console', {
            value: {
                log: (...args) => {
                    const formattedArgs = args.map(arg => {
                        if (typeof arg === 'undefined') return 'undefined';
                        if (arg === null) return 'null';
                        if (typeof arg === 'function') return '[Function]';
                        try {
                           return typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg);
                        } catch (e) {
                           return '[Unserializable Value]';
                        }
                    }).join(' ');
                    // Store console output as an object with a unique ID and the current step
                    this.output.push({
                        id: `console-${this.consoleLineIdCounter++}`,
                        text: formattedArgs,
                        step: this.trace.length // Mark the step at which this line was generated
                    });
                }
            },
            kind: 'const'
        });
        globalVariables.set('JSON', {
            value: {
                stringify: (value, replacer, space) => JSON.stringify(value, replacer, space)
            },
            kind: 'const'
        });
        globalVariables.set('Math', {
            value: Math,
            kind: 'const'
        });
        // Define Symbol to handle iterators from transpiled code (e.g., for...of loops)
        globalVariables.set('Symbol', {
            value: Symbol,
            kind: 'const'
        });
    }

    // --- Scope Management ---
    enterScope(type, name) { this.scopes.push({ type, name: name || type, variables: new Map() }); }
    exitScope() { this.scopes.pop(); }

    // --- Variable Management ---
    declareVariable(name, value, kind) {
        const currentScope = this.scopes[this.scopes.length - 1];
        if ((kind === 'let' || kind === 'const') && currentScope.variables.has(name)) {
            throw new Error(`SyntaxError: Identifier '${name}' has already been declared`);
        }
        currentScope.variables.set(name, { value, kind });
    }

    setVariable(name, value) {
        for (let i = this.scopes.length - 1; i >= 0; i--) {
            if (this.scopes[i].variables.has(name)) {
                const variable = this.scopes[i].variables.get(name);
                if (variable.kind === 'const') throw new Error(`TypeError: Assignment to constant variable.`);
                variable.value = value;
                return;
            }
        }
        // If not found, create it in the global scope (mimicking loose mode 'var' behavior)
        if (this.scopes.length === 1) {
            this.scopes[0].variables.set(name, { value, kind: 'var' });
            return;
        }
        throw new Error(`ReferenceError: ${name} is not defined`);
    }

    getVariable(name) {
        for (let i = this.scopes.length - 1; i >= 0; i--) {
            if (this.scopes[i].variables.has(name)) return this.scopes[i].variables.get(name).value;
        }
        throw new Error(`ReferenceError: ${name} is not defined`);
    }
    
    // Records the current state of the interpreter for visualization.
    step(node) {
        if (!node || !node.loc) return;
        // Create a serializable (JSON-friendly) version of the current scopes.
        const serializableScopes = this.scopes.map(scope => {
            const serializableVars = {};
            for (const [key, { value, kind }] of scope.variables.entries()) {
                let displayValue;
                if (value && value.type === 'Function') displayValue = `[Function: ${value.node.id ? value.node.id.name : 'anonymous'}]`;
                else if (value && value.type === 'Class') displayValue = `[Class: ${value.node.id.name}]`;
                else if (value && value.type === 'Instance') {
                    // For instances, show a simplified object representation for better display
                    const props = {};
                    for(const [propKey, propValue] of value.properties.entries()) {
                        props[propKey] = propValue;
                    }
                    displayValue = props;
                }
                else if (value === Math) displayValue = "[Math Object]";
                else if (typeof value === 'symbol') displayValue = value.toString();
                else displayValue = value;
                serializableVars[key] = { value: displayValue, kind };
            }
            return { type: scope.type, name: scope.name, variables: serializableVars, loc: scope.loc };
        });
        this.trace.push({
            loc: node.loc,
            scopes: serializableScopes,
            callStack: [...this.callStack],
            output: [...this.output], // Capture current state of output
        });
    }

    // --- Main Execution Logic ---
    run() {
        this.evaluate(this.ast.program);
        // Add a final step to show the end of execution.
        if (this.ast.program.loc) {
            const endLoc = { line: this.ast.program.loc.end.line, column: this.ast.program.loc.end.column + 1 };
            this.step({ loc: { start: endLoc, end: endLoc }});
        }
        return this.trace;
    }

    // The core evaluation function that processes each AST node.
    evaluate(node, options = {}) {
        // If a return statement was encountered, stop executing further statements in the current block.
        if (this.returnValue !== undefined) return;
        
        // Record the state *before* executing the current node.
        this.step(node);

        switch (node.type) {
            case 'Program':
            case 'File': // Babel's top-level node is sometimes 'File'
                const programBody = node.program ? node.program.body : node.body;
                for (const statement of programBody) {
                    this.evaluate(statement);
                    if (this.returnValue !== undefined) break; // Stop if a return occurs in global scope
                }
                break;
            case 'BlockStatement': {
                const isFunctionBody = options.isFunctionBody || false;
                if(!isFunctionBody) this.enterScope('block', 'Block');
                
                for (const statement of node.body) {
                    this.evaluate(statement);
                    if (this.returnValue !== undefined) break; // Stop block execution on return
                }
                 if(!isFunctionBody) this.exitScope();
                break;
            }
            case 'ExpressionStatement':
                return this.evaluate(node.expression);
            case 'VariableDeclaration':
                for (const declaration of node.declarations) {
                    const rightValue = declaration.init ? this.evaluate(declaration.init) : undefined;
                    if (node.kind === 'const' && rightValue === undefined) throw new Error('SyntaxError: Missing initializer in const declaration');
                    if (declaration.id.type === 'Identifier') {
                        this.declareVariable(declaration.id.name, rightValue, node.kind);
                    } else if (declaration.id.type === 'ArrayPattern') {
                        if (!Array.isArray(rightValue)) throw new TypeError('Attempted to destructure non-iterable value.');
                        declaration.id.elements.forEach((element, index) => {
                            if (element && element.type === 'Identifier') this.declareVariable(element.name, rightValue[index], node.kind);
                        });
                    }
                }
                break;
            case 'FunctionDeclaration':
                // For function declarations, we "hoist" them by declaring them in the current scope.
                this.declareVariable(node.id.name, { type: 'Function', node }, 'var');
                break;
             case 'ClassDeclaration':
                this.declareVariable(node.id.name, { type: 'Class', node }, 'const');
                break;
            case 'NewExpression': {
                const classDef = this.evaluate(node.callee);
                if (classDef.type !== 'Class') throw new TypeError(`${node.callee.name} is not a constructor`);

                const instance = { type: 'Instance', className: classDef.node.id.name, properties: new Map() };

                // Find and execute the constructor
                const constructor = classDef.node.body.body.find(method => method.kind === 'constructor');
                if (constructor) {
                    const args = node.arguments.map(arg => this.evaluate(arg));
                    this.executeMethod(instance, constructor, args);
                }

                return instance;
            }
            case 'ArrowFunctionExpression':
                // Arrow functions are expressions, so they return a function object.
                return { type: 'Function', node };
            case 'ReturnStatement':
                this.returnValue = node.argument ? this.evaluate(node.argument) : undefined;
                return this.returnValue;
            case 'IfStatement':
                this.enterScope('if', 'If');
                if (this.evaluate(node.test)) {
                    this.evaluate(node.consequent);
                } else if (node.alternate) {
                    this.evaluate(node.alternate);
                }
                this.exitScope();
                break;
            case 'ForStatement': {
                this.enterScope('loop', `For Loop`);
                if (node.init) this.evaluate(node.init);
                
                while (true) {
                    // Evaluate the test condition for each iteration.
                    const testResult = this.evaluate(node.test); 
                    if (!testResult || this.returnValue !== undefined) { // Exit if test is false or a return occurred.
                        break; 
                    }

                    this.evaluate(node.body);
                    if (this.returnValue !== undefined) { // Check again after body execution.
                        break; 
                    }
                    if (node.update) this.evaluate(node.update);
                }
                this.exitScope();
                break;
            }
             case 'WhileStatement': {
                this.enterScope('loop', 'While Loop');
                while (this.evaluate(node.test)) {
                    this.evaluate(node.body);
                    if (this.returnValue !== undefined) break;
                }
                this.exitScope();
                break;
            }
            case 'UnaryExpression': {
                const value = this.evaluate(node.argument);
                switch (node.operator) {
                    case '!': return !value;
                    case '-': return -value;
                    case '+': return +value;
                    case '~': return ~value;
                    case 'typeof': return typeof value;
                    default: throw new Error(`Unsupported unary operator: ${node.operator}`);
                }
            }
            case 'LogicalExpression': {
                const left = this.evaluate(node.left);
                // Implement short-circuiting for logical operators.
                if (node.operator === '||' && left) return left; 
                if (node.operator === '&&' && !left) return left;
                return this.evaluate(node.right);
            }
            case 'CallExpression': {
                const callee = this.evaluate(node.callee);
                const args = node.arguments.map(arg => this.evaluate(arg));

                if (callee && callee.type === 'Function') {
                    return this.executeFunction(callee, args, callee.node.id ? callee.node.id.name : '(anonymous)');
                } else if (callee && callee.type === 'Method') {
                    return this.executeMethod(callee.instance, callee.node, args);
                } else if (typeof callee === 'function') {
                    let context = null;
                    if (node.callee.type === 'MemberExpression') {
                         context = this.evaluate(node.callee.object);
                    }
                    return callee.apply(context, args);
                }

                throw new TypeError(`${(node.callee.property && node.callee.property.name) || 'expression'} is not a function`);
            }
             case 'ThisExpression': {
                for (let i = this.scopes.length - 1; i >= 0; i--) {
                    if (this.scopes[i].instanceContext) {
                        return this.scopes[i].instanceContext;
                    }
                }
                return undefined;
            }
            case 'AssignmentExpression': {
                if (node.left.type === 'MemberExpression' && node.left.object.type === 'ThisExpression') {
                    const instance = this.evaluate(node.left.object);
                    const propName = node.left.property.name;
                    const value = this.evaluate(node.right);
                    instance.properties.set(propName, value);
                    return value;
                }

                const rightValue = this.evaluate(node.right);
                if (node.left.type === 'Identifier') {
                    const varName = node.left.name;
                    if (node.operator === '=') {
                        this.setVariable(varName, rightValue);
                        return rightValue;
                    }
                    const leftValue = this.getVariable(varName);
                    let result;
                    switch (node.operator) {
                        case '+=': result = leftValue + rightValue; break;
                        case '-=': result = leftValue - rightValue; break;
                        case '*=': result = leftValue * rightValue; break;
                        case '/=': result = leftValue / rightValue; break;
                        default: throw new Error(`Unsupported assignment operator: ${node.operator}`);
                    }
                    this.setVariable(varName, result);
                    return result;
                } else if (node.left.type === 'MemberExpression') {
                    const obj = this.evaluate(node.left.object);
                     const prop = node.computed ? this.evaluate(node.left.property) : node.left.property.name;
                     if (node.operator === '=') {
                         if(obj.type === 'Instance') obj.properties.set(prop, rightValue);
                         else obj[prop] = rightValue;
                         return rightValue;
                     }
                    const leftValue = obj.type === 'Instance' ? obj.properties.get(prop) : obj[prop];
                    let result;
                    switch (node.operator) {
                        case '+=': result = leftValue + rightValue; break;
                        case '-=': result = leftValue - rightValue; break;
                        case '*=': result = leftValue * rightValue; break;
                        case '/=': result = leftValue / rightValue; break;
                        default: throw new Error(`Unsupported assignment operator: ${node.operator}`);
                    }
                    if(obj.type === 'Instance') obj.properties.set(prop, result);
                    else obj[prop] = result;
                    return result;
                }
                return rightValue;
            }
            case 'UpdateExpression': {
                const varName = node.argument.name;
                const originalValue = this.getVariable(varName);
                if (typeof originalValue !== 'number') throw new Error(`TypeError: Cannot apply operator '${node.operator}' to non-number`);
                const newValue = node.operator === '++' ? originalValue + 1 : originalValue - 1;
                this.setVariable(varName, newValue);
                return node.prefix ? newValue : originalValue;
            }
            case 'BinaryExpression': {
                const left = this.evaluate(node.left);
                const right = this.evaluate(node.right);
                switch (node.operator) {
                    case '+': return left + right; case '-': return left - right;
                    case '*': return left * right; case '/': return left / right;
                    case '%': return left % right;
                    case '===': return left === right; case '!==': return left !== right;
                    case '==': return left == right; case '!=': return left != right;
                    case '<': return left < right; case '>': return left > right;
                    case '<=': return left <= right; case '>=': return left >= right;
                    default: throw new Error(`Unsupported operator: ${node.operator}`);
                }
            }
            case 'MemberExpression': {
                const obj = this.evaluate(node.object);
                const prop = node.computed ? this.evaluate(node.property) : node.property.name;
                
                if (obj && obj.type === 'Instance') {
                    if (obj.properties.has(prop)) {
                        return obj.properties.get(prop);
                    }
                    const classDef = this.getVariable(obj.className);
                    const method = classDef.node.body.body.find(m => m.key.name === prop);
                    if (method) {
                        return { type: 'Method', node: method, instance: obj };
                    }
                    return undefined;
                }
                
                if (obj === null || typeof obj === 'undefined') {
                    throw new TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);
                }
                
                return obj[prop];
            }
            case 'Identifier': return this.getVariable(node.name);
            case 'ArrayExpression': return node.elements.map(el => this.evaluate(el));
            case 'ObjectExpression': {
                const obj = {};
                for (const prop of node.properties) {
                    const key = prop.key.name || this.evaluate(prop.key);
                    obj[key] = this.evaluate(prop.value);
                }
                return obj;
            }
            case 'Literal': case 'NumericLiteral': case 'StringLiteral': return node.value;
            case 'TemplateLiteral': {
                let str = '';
                for (let i = 0; i < node.quasis.length; i++) {
                    str += node.quasis[i].value.cooked;
                    if (i < node.expressions.length) str += this.evaluate(node.expressions[i]);
                }
                return str;
            }
            default:
                if (!['Property', 'MethodDefinition', 'ClassBody', 'ClassMethod'].includes(node.type)) console.warn(`Unsupported AST node type: ${node.type}`);
        }
    }

    executeFunction(func, args, name) {
        this.callStack.push(name);
        this.enterScope('function', name);
        func.node.params.forEach((param, i) => this.declareVariable(param.name, args[i], 'let'));
        
        const savedReturnValue = this.returnValue;
        this.returnValue = undefined;
        this.evaluate(func.node.body, {isFunctionBody: true});
        const result = this.returnValue;
        this.returnValue = savedReturnValue;
        
        this.scopes.pop();
        this.callStack.pop();
        return result;
    }

    executeMethod(instance, methodNode, args) {
        const methodName = methodNode.key.name;
        this.callStack.push(`${instance.className}.${methodName}`);
        
        const methodScope = { type: 'function', name: methodName, variables: new Map(), instanceContext: instance };
        this.scopes.push(methodScope);
        
        const functionExpression = methodNode.value || methodNode;
        if (!functionExpression || !functionExpression.params) {
             throw new Error(`Interpreter Error: Could not find function definition for method ${methodName}`);
        }

        functionExpression.params.forEach((param, i) => this.declareVariable(param.name, args[i], 'let'));
        
        const savedReturnValue = this.returnValue;
        this.returnValue = undefined;
        this.evaluate(functionExpression.body, {isFunctionBody: true});
        const result = this.returnValue;
        this.returnValue = savedReturnValue;
        
        this.scopes.pop();
        this.callStack.pop();
        return result;
    }
}

const initialCode = `// A simple Queue class for the BFS algorithm
class Queue {
  constructor() {
    this.items = [];
  }

  enqueue(element) {
    this.items.push(element);
  }

  dequeue() {
    if (this.isEmpty()) {
      return "Underflow";
    }
    return this.items.shift();
  }

  front() {
    if (this.isEmpty()) {
      return "No elements in Queue";
    }
    return this.items[0];
  }

  isEmpty() {
    return this.items.length == 0;
  }
}

// Breadth-First Search function
function bfs(graph, startNode) {
  let visited = {}; // Use an object as a simple set
  let q = new Queue();

  visited[startNode] = true;
  q.enqueue(startNode);
  console.log("Start traversal at: " + startNode);

  while (!q.isEmpty()) {
    let currentNode = q.dequeue();

    let neighbors = graph[currentNode];
    for (let i = 0; i < neighbors.length; i++) {
      let neighbor = neighbors[i];
      if (!visited[neighbor]) {
        visited[neighbor] = true;
        q.enqueue(neighbor);
        console.log("Visiting neighbor: " + neighbor);
      }
    }
  }
}

// Graph represented as an adjacency list
const graph = {
  'A': ['B', 'C'],
  'B': ['D', 'E'],
  'C': ['F'],
  'D': [],
  'E': ['F'],
  'F': []
};

bfs(graph, 'A');
`;


// --- CodeMirror Setup for Highlighting ---
const setHighlightEffect = StateEffect.define();
const highlightMark = Decoration.mark({ attributes: { style: 'background-color: var(--primary-container); color: var(--on-primary-container);' }});

const highlightField = StateField.define({
    create() { return Decoration.none; },
    update(decorations, tr) {
        decorations = decorations.map(tr.changes);
        for (let e of tr.effects) {
            if (e.is(setHighlightEffect)) {
                const { from, to } = e.value || {};
                if (typeof from === 'number' && typeof to === 'number' && from < to) {
                    return Decoration.set([highlightMark.range(from, to)]);
                }
                return Decoration.none;
            }
        }
        return decorations;
    },
    provide: f => EditorView.decorations.from(f)
});

// Custom theme for CodeMirror to match the Material Design look.
const googleThemeLight = EditorView.theme({
    "&": { color: "var(--on-surface)", backgroundColor: "var(--surface-container-high)", fontFamily: "'Google Sans', sans-serif", fontSize: '14px', borderRadius: '12px', border: '1px solid var(--outline-variant)' },
    ".cm-content": { caretColor: "var(--primary)" },
    "&.cm-focused .cm-cursor": { borderLeftColor: "var(--primary)" },
    ".cm-selectionBackground, .cm-content ::selection": { backgroundColor: "var(--primary-container) !important" },
    ".cm-gutters": { backgroundColor: "var(--surface-container-high)", color: "var(--on-surface-variant)", border: "none", borderRadius: '12px 0 0 12px', padding: '0 8px' },
    ".cm-line": { paddingLeft: '12px' },
    ".cm-keyword": {color: "var(--syntax-keyword)"},
    ".cm-def": {color: "var(--syntax-definition)"},
    ".cm-operator": {color: "var(--syntax-operator)"},
    ".cm-string": {color: "var(--syntax-string)"},
    ".cm-string-2": {color: "var(--syntax-string2)"},
    ".cm-comment": {color: "var(--syntax-comment)", fontStyle: "italic"},
    ".cm-number": {color: "var(--syntax-number)"},
    ".cm-variable": {color: "var(--syntax-variable)"},
    ".cm-variable-2": {color: "var(--syntax-variable2)"},
    ".cm-property": {color: "var(--syntax-property)"},
    ".cm-atom": {color: "var(--syntax-atom)"},
    ".cm-meta": {color: "var(--syntax-meta)"},
}, {dark: false});

let themeCompartment = new Compartment();

// --- React Components for UI ---

// Renders a single variable, with animation when its value changes.
const VariableItem = React.memo(({ scopeName, varName, value, kind, isChanged }) => {
    const [isAnimating, setIsAnimating] = useState(false);
    const prevIsChanged = useRef(isChanged);

    useEffect(() => {
        if (isChanged && !prevIsChanged.current) {
            setIsAnimating(true);
            const timer = setTimeout(() => setIsAnimating(false), 800);
            return () => clearTimeout(timer);
        }
        if (!isChanged) {
            setIsAnimating(false);
        }
        prevIsChanged.current = isChanged;
    }, [isChanged]);

    // Use JSON.stringify without the space argument for a compact, single-line representation.
    const displayValue = JSON.stringify(value);


    return (
        <p className={`text-xs font-mono p-1 rounded transition-colors duration-300 ${isAnimating ? 'animate-variable-highlight' : ''}`}>
            <span className={`mr-1 font-medium ${kind === 'const' ? 'text-tertiary' : 'text-secondary'}`}>({kind})</span>
            <span className="text-on-surface-variant">â€¢ {varName}: </span>
            <span className="text-primary whitespace-pre-wrap break-all">{displayValue}</span>
        </p>
    );
});


// Renders a single console line, with animation on first appearance.
const ConsoleLine = React.memo(({ line, isHighlighted }) => {
    const [isAnimating, setIsAnimating] = useState(false);

    useEffect(() => {
        if (isHighlighted) {
            setIsAnimating(true);
            const timer = setTimeout(() => setIsAnimating(false), 800);
            return () => clearTimeout(timer);
        }
    }, [isHighlighted]);

    return (
        <div className={`p-1 rounded transition-colors duration-300 ${isAnimating ? 'animate-console-line-highlight' : ''}`}>
            <span className="text-on-surface-variant mr-2">&gt;</span>{line.text}
        </div>
    );
});

// Recursively renders scope boxes with proper nesting.
const renderScopes = (scopes, changedVariables) => {
    if (!scopes || scopes.length === 0) {
        return <p className="text-on-surface-variant italic p-3">-- No scopes --</p>;
    }

    const scopeHierarchy = [];
    const stack = [];

    // First pass: Process and filter scopes. Merge function body blocks into the function scope.
    const processedScopes = [];
    for (let i = 0; i < scopes.length; i++) {
        const current = { ...scopes[i], variables: {...scopes[i].variables} }; // Deep copy
        const prev = i > 0 ? processedScopes[processedScopes.length-1] : null;

        if (
            current.type === 'block' && prev && prev.type === 'function'
        ) {
            Object.assign(prev.variables, current.variables);
        } else if (current.type === 'block' && Object.keys(current.variables).length === 0) {
            // Skip empty block scopes
        }
        else {
            processedScopes.push(current);
        }
    }


    // Build the hierarchy from the flat list of scopes
    processedScopes.forEach(scope => {
        while (stack.length > 0 && !isAncestor(stack[stack.length - 1], scope, processedScopes)) {
            stack.pop();
        }

        const parent = stack.length > 0 ? stack[stack.length - 1] : null;
        const scopeNode = { ...scope, children: [] };
        
        if (parent) {
            parent.children.push(scopeNode);
        } else {
            scopeHierarchy.push(scopeNode);
        }
        stack.push(scopeNode);
    });

    // Helper to determine parent-child relationship based on original trace order
    function isAncestor(potentialParent, child, allScopes) {
       const parentIndex = allScopes.findIndex(s => s.name === potentialParent.name && s.type === potentialParent.type);
       const childIndex = allScopes.findIndex(s => s.name === child.name && s.type === child.type);
       return parentIndex < childIndex;
    }

    return (
        <ScopeComponent scopes={scopeHierarchy} changedVariables={changedVariables} />
    );
};

// List of boilerplate variables to hide from the global scope view.
const an_IGNORE_LIST = ['console', 'JSON', 'Math', 'Symbol'];

const ScopeComponent = ({ scopes, changedVariables, depth = 0 }) => {
    if (!scopes || scopes.length === 0) return null;
    
    return scopes.map((scope, index) => {
        let scopeDisplayName = scope.name;
        let scopeIcon = '';

        // Assign icons based on scope type
        if (scope.type === 'global') {
            scopeIcon = 'ðŸŒ'; scopeDisplayName = 'Global Scope';
        } else if (scope.type === 'function') {
            scopeIcon = 'ï¿½'; scopeDisplayName = `${scope.name} Scope`;
        } else if (scope.type === 'loop') {
            scopeIcon = 'ðŸ”'; scopeDisplayName = scope.name;
        } else if (scope.type === 'if') {
             scopeIcon = 'ðŸ¤”'; scopeDisplayName = 'If Block';
        }
        else if (scope.type === 'block') {
            scopeIcon = 'ðŸ”‘'; scopeDisplayName = 'Block Scope';
        }

        // Filter out ignored variables from the global scope
        const variablesToDisplay = scope.type === 'global'
            ? Object.entries(scope.variables).filter(([key]) => !key.startsWith('_') && !an_IGNORE_LIST.includes(key))
            : Object.entries(scope.variables);


        const variablesContent = variablesToDisplay.length > 0 ? (
            <div className="space-y-1">
                {variablesToDisplay.map(([key, varData]) => (
                    <VariableItem
                        key={`${scope.name}-${key}`}
                        scopeName={scope.name}
                        varName={key}
                        value={varData.value}
                        kind={varData.kind}
                        isChanged={changedVariables.some(c => c.scopeName === scope.name && c.varName === key)}
                    />
                ))}
            </div>
        ) : null;

        // Don't render the global scope box if it becomes empty after filtering
        if (scope.type === 'global' && !variablesContent && (!scope.children || scope.children.length === 0)) {
            return null;
        }

        return (
            <div key={`${scope.type}-${scope.name}-${index}`}
                className={`bg-surface-container-low rounded-lg border border-outline-variant p-3 transition-all duration-300`}
                style={{ marginLeft: `${depth * 16}px` }}>
                <h4 className="text-sm font-medium text-on-surface-variant mb-2 flex items-center gap-2">
                    <span className="text-lg">{scopeIcon}</span>
                    <span>{scopeDisplayName}</span>
                </h4>
                {variablesContent}
                {!variablesContent && (!scope.children || scope.children.length === 0) && (
                    <p className="text-on-surface-variant italic text-xs">-- empty --</p>
                )}
                {scope.children.length > 0 && (
                     <div className="mt-2 space-y-2">
                        <ScopeComponent scopes={scope.children} changedVariables={changedVariables} depth={depth + 1} />
                     </div>
                )}
            </div>
        );
    });
};


// Reusable IconButton component
const IconButton = ({ onClick, disabled, children, ariaLabel, className = '' }) => (
    <button
        onClick={onClick}
        disabled={disabled}
        aria-label={ariaLabel}
        className={`flex items-center justify-center h-10 w-10 rounded-full transition-colors duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-primary ${className}`}
    >
        <span className="material-symbols-outlined text-xl">{children}</span>
    </button>
);


export default function App() {
    const editorRef = useRef(null);
    const viewRef = useRef(null);
    const [isBabelLoaded, setIsBabelLoaded] = useState(false);
    const [code, setCode] = useState(initialCode);
    const [trace, setTrace] = useState([]);
    const [currentStep, setCurrentStep] = useState(0);
    const [error, setError] = useState(null);
    const [isPlaying, setIsPlaying] = useState(false);
    const [autoplaySpeed, setAutoplaySpeed] = useState(250);
    const shouldScrollRef = useRef(false);
    const [changedVariables, setChangedVariables] = useState([]); 
    const [highlightedConsoleLineIds, setHighlightedConsoleLineIds] = useState([]);
    const [isDarkMode, setIsDarkMode] = useState(false);

    // Effect to load external scripts and fonts
    useEffect(() => {
        const fontLink = document.createElement('link');
        fontLink.href = "https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&display=swap";
        fontLink.rel = "stylesheet";
        
        const iconLink = document.createElement('link');
        iconLink.href = "https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200";
        iconLink.rel = "stylesheet";

        document.head.appendChild(fontLink);
        document.head.appendChild(iconLink);
        
        // Load Babel for AST parsing
        if (window.Babel) {
          setIsBabelLoaded(true);
        } else {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/@babel/standalone/babel.min.js';
            script.async = true;
            script.onload = () => setIsBabelLoaded(true);
            script.onerror = () => setError("Babel script failed to load.");
            document.body.appendChild(script);
        }
        
        return () => { 
            if(document.head.contains(fontLink)) document.head.removeChild(fontLink);
            if(document.head.contains(iconLink)) document.head.removeChild(iconLink);
        };
    }, []);

    // Effect to initialize CodeMirror editor
    useEffect(() => {
        if (isBabelLoaded && editorRef.current && !viewRef.current) {
            viewRef.current = new EditorView({
                state: EditorState.create({
                    doc: code,
                    extensions: [
                        lineNumbers(),
                        history(),
                        keymap.of([...defaultKeymap, indentWithTab]),
                        javascript({ jsx: false }), // Set jsx to false
                        themeCompartment.of(isDarkMode ? oneDark : googleThemeLight),
                        highlightField,
                        EditorView.updateListener.of(up => {
                            if (up.docChanged) {
                                setCode(up.state.doc.toString());
                                handleReset(); // Reset visualization if code changes
                            }
                        }),
                    ],
                }),
                parent: editorRef.current
            });
        }
        return () => { viewRef.current?.destroy(); viewRef.current = null; };
    }, [isBabelLoaded]);

    // Effect to toggle CodeMirror theme
    useEffect(() => {
        if (viewRef.current) {
            viewRef.current.dispatch({
                effects: themeCompartment.reconfigure(isDarkMode ? oneDark : googleThemeLight)
            });
        }
    }, [isDarkMode]);

    // Effect for highlighting, variable change detection, and console output changes
    useEffect(() => {
        if (!trace[currentStep] || !viewRef.current) {
            if (viewRef.current) viewRef.current.dispatch({ effects: setHighlightEffect.of(null) });
            setChangedVariables([]);
            setHighlightedConsoleLineIds([]);
            return;
        };
        const view = viewRef.current;
        const { loc } = trace[currentStep];
        try {
            // --- Code line highlighting ---
            const from = view.state.doc.line(loc.start.line).from + loc.start.column;
            const to = view.state.doc.line(loc.end.line).from + loc.end.column;
            
            let effects = [];
            if (from < to) {
                effects.push(setHighlightEffect.of({ from, to }));
            } else {
                effects.push(setHighlightEffect.of(null));
            }

            if (shouldScrollRef.current) {
                effects.push(EditorView.scrollIntoView(from, { y: 'center' }));
                shouldScrollRef.current = false;
            }
            view.dispatch({ effects });

            // --- State Change Detection for Animation ---
            const prevSnapshot = trace[currentStep - 1];
            const currentSnapshot = trace[currentStep];
            const newChangedVariables = [];
            const newHighlightedConsoleLines = [];

            if (prevSnapshot && currentSnapshot) {
                // --- Variable changes detection ---
                const prevScopesMap = new Map(prevSnapshot.scopes.map(s => [s.name, s]));
                currentSnapshot.scopes.forEach(currentScope => {
                    const prevScope = prevScopesMap.get(currentScope.name);
                    const currentVars = currentScope.variables;
                    
                    if (!prevScope) { // Scope was created
                         Object.keys(currentVars).forEach(varName => newChangedVariables.push({scopeName: currentScope.name, varName}));
                    } else { // Scope existed, check variables
                         const prevVars = prevScope.variables;
                         Object.entries(currentVars).forEach(([varName, {value: currentValue}]) => {
                              if (!prevVars[varName] || JSON.stringify(prevVars[varName].value) !== JSON.stringify(currentValue)) {
                                   newChangedVariables.push({scopeName: currentScope.name, varName});
                              }
                         });
                    }
                });

                // --- Console output changes (new lines) ---
                if (currentSnapshot.output.length > prevSnapshot.output.length) {
                    for (let i = prevSnapshot.output.length; i < currentSnapshot.output.length; i++) {
                        newHighlightedConsoleLineIds.push(currentSnapshot.output[i].id);
                    }
                }
            }
            setChangedVariables(newChangedVariables);
            setHighlightedConsoleLineIds(newHighlightedConsoleLines);

        } catch(e) {
            console.error("Failed to update view for highlighting or state detection:", e);
            setChangedVariables([]);
            setHighlightedConsoleLineIds([]);
        }
    }, [currentStep, trace]);
    
    // Effect for autoplay functionality
    useEffect(() => {
        if (!isPlaying) return;
        const interval = setInterval(() => {
            setCurrentStep(prev => {
                const nextStep = prev + 1;
                if (nextStep >= trace.length) {
                    setIsPlaying(false);
                    return prev;
                }
                shouldScrollRef.current = true;
                return nextStep;
            });
        }, autoplaySpeed);
        return () => clearInterval(interval);
    }, [isPlaying, autoplaySpeed, trace.length]);

    // --- Event Handlers ---

    const handleVisualize = () => {
        setError(null);
        setIsPlaying(false);
        setChangedVariables([]);
        setHighlightedConsoleLineIds([]);
        try {
            // Use presets: [] to avoid transforming modern syntax like classes
            const ast = window.Babel.transform(code, { presets: [], ast: true }).ast;
            const interpreter = new Interpreter(ast);
            const executionTrace = interpreter.run();
            setTrace(executionTrace);
            setCurrentStep(0);
            if (executionTrace.length > 0) shouldScrollRef.current = true;
            else setError("Could not generate a trace. Code may be empty or invalid.");
        } catch (e) {
            setError(`Error: ${e.message}`);
            setTrace([]);
            console.error(e);
        }
    };

    const handleReset = () => {
        setIsPlaying(false);
        setTrace([]);
        setCurrentStep(0);
        setError(null);
        shouldScrollRef.current = false;
        setChangedVariables([]);
        setHighlightedConsoleLineIds([]);
    };
    
    const handlePrevStep = () => {
        if (currentStep > 0) {
            shouldScrollRef.current = true;
            setCurrentStep(currentStep - 1);
        }
    };

    const handleNextStep = () => {
        if (currentStep < trace.length -1) {
            shouldScrollRef.current = true;
            setCurrentStep(currentStep + 1);
        }
    };

    const handleTogglePlay = () => {
        if (trace.length === 0) return;
        if(currentStep >= trace.length - 1) {
            shouldScrollRef.current = true;
            setCurrentStep(0);
        }
        setIsPlaying(prev => !prev);
    };
    
    const handleSliderChange = (e) => {
        shouldScrollRef.current = false; // Don't scroll on manual slide
        setCurrentStep(Number(e.target.value));
    };
    
    const currentSnapshot = trace[currentStep] || { scopes: [], callStack: [], output: [] };

    return (
        <div
            className={`font-google-sans min-h-screen transition-colors duration-300 ${isDarkMode ? 'dark' : ''}`}
            style={{ backgroundColor: 'var(--surface)', color: 'var(--on-surface)' }}
        >
            <style>{`
                :root {
                    /* General UI Colors - Light Mode */
                    --surface: #f8f9fa;
                    --on-surface: #1f2023;
                    --on-surface-variant: #45474a;
                    --surface-container: #f0f3f8;
                    --surface-container-low: #e9eef4;
                    --surface-container-high: #ffffff;
                    --outline: #dce1e9;
                    --outline-variant: #c8ccd1;
                    --primary: #0b57d0;
                    --on-primary: #ffffff;
                    --primary-container: #d3e3fd;
                    --on-primary-container: #001849;
                    --secondary: #555f71;
                    --on-secondary: #ffffff;
                    --tertiary: #6e5676;
                    --on-tertiary: #ffffff;
                    --error: #b3261e;
                    --error-container: #f9dedc;
                    --on-error-container: #410e0b;

                    /* Syntax Highlighting Colors - Light Mode */
                    --syntax-keyword: #00008b; --syntax-definition: #0000ff;
                    --syntax-operator: #800000; --syntax-string: #2e8b57;
                    --syntax-string2: #ff00ff; --syntax-comment: #888888;
                    --syntax-number: #0000cd; --syntax-variable: #212121;
                    --syntax-variable2: #5f0087; --syntax-property: #c80000;
                    --syntax-atom: #000080; --syntax-meta: #555;
                }
                .dark {
                    /* General UI Colors - Dark Mode */
                    --surface: #121316; --on-surface: #e2e2e6;
                    --on-surface-variant: #c5c6ca; --surface-container: #1f2023;
                    --surface-container-low: #1a1c1e; --surface-container-high: #2a2b2e;
                    --outline: #45474a; --outline-variant: #2f3033;
                    --primary: #a8c7fa; --on-primary: #002f66;
                    --primary-container: #00458e; --on-primary-container: #d3e3fd;
                    --secondary: #bdc7dc; --on-secondary: #2d313c;
                    --tertiary: #dbbde2; --on-tertiary: #3e2a44;
                    --error: #ffb4ab; --error-container: #93000a; --on-error-container: #ffdad6;

                    /* Syntax Highlighting Colors (uses oneDark theme) */
                }
                .material-symbols-outlined { font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24; }
                input[type=range] { -webkit-appearance: none; appearance: none; background: transparent; cursor: pointer; width: 100%; }
                input[type=range]:focus { outline: none; }
                input[type=range]::-webkit-slider-runnable-track { background: var(--primary-container); height: 4px; border-radius: 99px; }
                input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -6px; background-color: var(--primary); height: 16px; width: 16px; border-radius: 50%; }
                input[type=range]:focus::-webkit-slider-thumb { box-shadow: 0 0 0 4px var(--surface-container), 0 0 0 6px var(--primary); }

                /* Animation Keyframes */
                @keyframes highlight-bg {
                    0%, 100% { background-color: transparent; }
                    20%, 80% { background-color: var(--primary-container); }
                }
                .animate-variable-highlight { animation: highlight-bg 0.8s ease-out; }
                .animate-console-line-highlight { animation: highlight-bg 0.8s ease-out; }
            `}</style>
            
            <div className="min-h-screen flex flex-col lg:flex-row p-4 sm:p-6 lg:p-8 gap-6">
                {/* Left section: Header, Code Editor, and Console Output */}
                <div className="flex flex-col flex-1 lg:w-3/5 space-y-4">
                    <header className="flex justify-between items-center pb-2 border-b border-outline-variant">
                        <div>
                            <h1 className="text-2xl font-medium text-on-surface">Code Visualizer</h1>
                            <p className="text-base text-on-surface-variant">Step-through JavaScript execution with Material Design</p>
                        </div>
                        <IconButton onClick={() => setIsDarkMode(p => !p)} ariaLabel="Toggle Dark Mode" className="text-on-surface-variant hover:bg-on-surface/10">
                            {isDarkMode ? 'light_mode' : 'dark_mode'}
                        </IconButton>
                    </header>
                    <div className="flex-grow min-h-[400px] border border-outline-variant rounded-xl overflow-hidden">
                        <div ref={editorRef} className="h-full w-full"></div>
                    </div>
                    <div className="p-4 bg-surface-container rounded-xl border border-outline-variant">
                        <h3 className="text-base font-medium text-on-surface-variant mb-2 pb-2 border-b border-outline-variant">Console</h3>
                        <div className="bg-surface-container-low p-3 rounded-lg font-mono text-sm space-y-1 text-on-surface whitespace-pre-wrap min-h-[80px] max-h-48 overflow-y-auto border border-outline-variant">
                            {currentSnapshot.output.length > 0 ? (
                                currentSnapshot.output.map((line) => ( 
                                    <ConsoleLine 
                                        key={line.id} 
                                        line={line} 
                                        isHighlighted={highlightedConsoleLineIds.includes(line.id)} 
                                    />
                                ))
                            ) : ( <p className="text-on-surface-variant italic">No console output yet.</p> )}
                        </div>
                    </div>
                </div>

                {/* Right section: Controls, Scopes, Call Stack */}
                <div className="flex flex-col lg:w-2/5 space-y-6">
                    <div className="p-4 bg-surface-container rounded-xl border border-outline-variant space-y-4">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <button onClick={handleVisualize} disabled={!isBabelLoaded} className="flex items-center gap-2 text-sm font-medium h-10 px-6 rounded-full bg-primary text-on-primary hover:shadow-lg transition-shadow disabled:bg-on-surface/20 disabled:text-on-surface/50 disabled:shadow-none">
                                    <span className="material-symbols-outlined">science</span>
                                    Visualize
                                </button>
                                <IconButton onClick={handleReset} ariaLabel="Reset Visualizer" className="text-on-surface-variant hover:bg-on-surface/10">
                                    replay
                                </IconButton>
                            </div>
                            <div className="flex items-center gap-2">
                                <IconButton onClick={handlePrevStep} disabled={!trace.length || currentStep === 0 || isPlaying} ariaLabel="Previous Step" className="text-primary hover:bg-primary-container disabled:text-on-surface/30 disabled:hover:bg-transparent">
                                    skip_previous
                                </IconButton>
                                <IconButton onClick={handleTogglePlay} disabled={!trace.length} ariaLabel={isPlaying ? 'Pause' : 'Autoplay'} className="text-on-primary bg-primary w-14 h-10 rounded-full hover:shadow-lg transition-shadow disabled:bg-on-surface/20 disabled:text-on-primary/50 disabled:shadow-none">
                                   {isPlaying ? 'pause' : 'play_arrow'}
                                </IconButton>
                                <IconButton onClick={handleNextStep} disabled={!trace.length || currentStep >= trace.length - 1 || isPlaying} ariaLabel="Next Step" className="text-primary hover:bg-primary-container disabled:text-on-surface/30 disabled:hover:bg-transparent">
                                    skip_next
                                </IconButton>
                            </div>
                        </div>
                        {trace.length > 0 && (
                            <div className="space-y-3 pt-2">
                                <div className="flex items-center gap-4">
                                   <label htmlFor="step-slider" className="text-sm font-medium text-on-surface-variant flex-shrink-0">Step</label>
                                   <input id="step-slider" type="range" min="0" max={trace.length > 0 ? trace.length - 1 : 0} value={currentStep} onChange={handleSliderChange} disabled={isPlaying}/>
                                   <span className="text-sm font-mono text-on-surface-variant bg-surface-container-low px-2 py-1 rounded-md w-24 text-center">{currentStep + 1} / {trace.length}</span>
                                </div>
                                <div className="flex items-center gap-4">
                                   <label htmlFor="speed-slider" className="text-sm font-medium text-on-surface-variant flex-shrink-0">Speed</label>
                                   <input id="speed-slider" type="range" min="50" max="1000" step="50" value={autoplaySpeed} onChange={(e) => setAutoplaySpeed(Number(e.target.value))}/>
                                   <span className="text-sm font-mono text-on-surface-variant bg-surface-container-low px-2 py-1 rounded-md w-24 text-center">{autoplaySpeed} ms</span>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    {error && (
                        <div className="p-4 rounded-xl bg-error-container text-on-error-container border border-error font-medium text-sm">
                            {error}
                        </div>
                    )}

                    <div className="p-4 bg-surface-container rounded-xl border border-outline-variant flex-grow overflow-y-auto min-h-[200px]">
                        <h3 className="text-base font-medium text-on-surface-variant mb-2 pb-2 border-b border-outline-variant">Scopes</h3>
                        <div className="font-mono text-sm space-y-2">
                            {trace.length > 0 ? renderScopes(currentSnapshot.scopes, changedVariables) : <p className="text-on-surface-variant italic p-3">Click "Visualize" to begin.</p>}
                        </div>
                    </div>

                    <div className="p-4 bg-surface-container rounded-xl border border-outline-variant">
                        <h3 className="text-base font-medium text-on-surface-variant mb-2 pb-2 border-b border-outline-variant">Call Stack</h3>
                        <div className="font-mono text-sm space-y-2">
                            {currentSnapshot.callStack.length > 0 ? (
                                currentSnapshot.callStack.slice().reverse().map((funcName, index) => (
                                    <div key={index} className="bg-primary-container text-on-primary-container p-2 rounded-lg text-center font-medium">{funcName}</div>
                                ))
                            ) : ( <p className="text-on-surface-variant italic">Call stack is empty.</p> )}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
}
