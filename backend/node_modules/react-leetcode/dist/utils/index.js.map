{"version":3,"file":"index.js","sources":["../../src/utils/index.ts"],"sourcesContent":["import { ContestInfo } from \"../types\";\r\n\r\n/**\r\n * Extracts the last segment of a URL path.\r\n * @param {string} url - The URL from which to extract the path.\r\n * @returns {string} The last segment of the URL path.\r\n * @example\r\n * // returns 'page.html'\r\n * getPath('https://example.com/path/to/page.html');\r\n */\r\nexport function getPath(url: string): string {\r\n    const arr = url.split('/')\r\n    return arr[arr.length-1];\r\n}\r\n\r\n/**\r\n * Calculates coordinates for plotting a rating history graph based on contest information.\r\n * @param {ContestInfo[]} history - Array of contest information representing rating history.\r\n * @returns {object[]} An array of objects containing x and y coordinates along with contest information.\r\n */\r\nexport function getCordinates(history: ContestInfo[]): ({ x: number, y: number } & ContestInfo)[]{\r\n    if(history.length === 0) return [];\r\n\r\n    if(history.length === 1) return [{\r\n        x: 0,\r\n        y: 0,\r\n        ...history[0]\r\n    }]\r\n    const startTime = history[0].contest.startTime;\r\n    const endTime = history[history.length - 1].contest.startTime;\r\n    const [minRating, maxRating] = history.reduce(\r\n        ([min, max], { rating }) => [Math.min(min, rating), Math.max(max, rating)],\r\n        [Infinity, -Infinity],\r\n    );\r\n\r\n    const width = 500;\r\n    const height = 150;\r\n\r\n    const x_scale = width / (endTime - startTime);\r\n    const y_scale = height / (maxRating - minRating);\r\n\r\n    const points = history.map((d) => {\r\n        const { rating } = d;\r\n        const time = d.contest.startTime;\r\n        const x = Math.round((time - startTime) * x_scale);\r\n        const y = Math.round((maxRating - rating) * y_scale);\r\n        \r\n        return {\r\n        x,\r\n        y,\r\n        ...d\r\n        };\r\n    });\r\n\r\n    return points;\r\n}\r\n\r\n/**\r\n * Calculates various parameters required for rendering a line chart.\r\n * @param {number} width - The width of the chart area.\r\n * @param {number} height - The height of the chart area.\r\n * @param {Array<ContestInfo & { x: number, y: number }>} data - Array of data points with x and y coordinates.\r\n * @param {number} precision - The precision of the data values.\r\n * @returns  An object containing calculated parameters for rendering the chart, or undefined if data is empty.\r\n */\r\nexport function LineChartCalculations(width: number, height: number, data: (ContestInfo & { x: number, y: number })[], precision: number) {\r\n    if(data.length === 0) return undefined;\r\n\r\n    const FONT_SIZE = width / 50;\r\n\r\n    const maximumXFromData = Math.max(...data.map(e => e.x)) || 1;\r\n    const maximumYFromData = Math.max(...data.map(e => e.y)) || 1;\r\n\r\n    const digits =\r\n        parseFloat(maximumYFromData.toString()).toFixed(precision).length + 1;\r\n\r\n    const padding = (FONT_SIZE + digits) * 2;\r\n    const chartWidth = width - padding * 2;\r\n    const chartHeight = height - padding * 2;\r\n\r\n    const points = data.map((element) => {\r\n                const x = (element.x / maximumXFromData) * chartWidth + padding;\r\n                const y = (element.y / maximumYFromData) * chartHeight + padding;\r\n                return `${x},${y}`;\r\n            }).join(\" \");\r\n\r\n    return {\r\n        FONT_SIZE,\r\n        padding,\r\n        maximumXFromData,\r\n        maximumYFromData,\r\n        chartHeight,\r\n        chartWidth,\r\n        points\r\n    }\r\n}\r\n\r\n/**\r\n * Calculates opacity based on the count and maximum value.\r\n * @param {number} count - The count value.\r\n * @param {number} [max=8] - The maximum value. Default is 8.\r\n * @returns {number} The calculated opacity value.\r\n */\r\nexport function calcOpacity(count: number, max: number = 8): number {\r\n    return Math.sin(Math.min(1, (count + 0.5) / max) * Math.PI * 0.5);\r\n}\r\n"],"names":["getPath","url","arr","getCordinates","history","startTime","endTime","minRating","maxRating","min","max","rating","width","height","x_scale","y_scale","d","time","y","LineChartCalculations","data","precision","FONT_SIZE","maximumXFromData","e","maximumYFromData","digits","padding","chartWidth","chartHeight","points","element","calcOpacity","count"],"mappings":"AAUO,SAASA,EAAQC,GAAqB;AACnC,QAAAC,IAAMD,EAAI,MAAM,GAAG;AAClB,SAAAC,EAAIA,EAAI,SAAO,CAAC;AAC3B;AAOO,SAASC,EAAcC,GAAmE;AAC7F,MAAGA,EAAQ,WAAW;AAAG,WAAO;AAEhC,MAAGA,EAAQ,WAAW;AAAG,WAAO,CAAC;AAAA,MAC7B,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAGA,EAAQ,CAAC;AAAA,IAAA,CACf;AACD,QAAMC,IAAYD,EAAQ,CAAC,EAAE,QAAQ,WAC/BE,IAAUF,EAAQA,EAAQ,SAAS,CAAC,EAAE,QAAQ,WAC9C,CAACG,GAAWC,CAAS,IAAIJ,EAAQ;AAAA,IACnC,CAAC,CAACK,GAAKC,CAAG,GAAG,EAAE,QAAAC,QAAa,CAAC,KAAK,IAAIF,GAAKE,CAAM,GAAG,KAAK,IAAID,GAAKC,CAAM,CAAC;AAAA,IACzE,CAAC,OAAU,MAAS;AAAA,EAAA,GAGlBC,IAAQ,KACRC,IAAS,KAETC,IAAUF,KAASN,IAAUD,IAC7BU,IAAUF,KAAUL,IAAYD;AAe/B,SAbQH,EAAQ,IAAI,CAACY,MAAM;AACxB,UAAA,EAAE,QAAAL,EAAW,IAAAK,GACbC,IAAOD,EAAE,QAAQ,WACjB,IAAI,KAAK,OAAOC,IAAOZ,KAAaS,CAAO,GAC3CI,IAAI,KAAK,OAAOV,IAAYG,KAAUI,CAAO;AAE5C,WAAA;AAAA,MACP;AAAA,MACA,GAAAG;AAAA,MACA,GAAGF;AAAA,IAAA;AAAA,EACH,CACH;AAGL;AAUO,SAASG,EAAsBP,GAAeC,GAAgBO,GAAkDC,GAAmB;AACtI,MAAGD,EAAK,WAAW;AAAU;AAE7B,QAAME,IAAYV,IAAQ,IAEpBW,IAAmB,KAAK,IAAI,GAAGH,EAAK,IAAI,CAAKI,MAAAA,EAAE,CAAC,CAAC,KAAK,GACtDC,IAAmB,KAAK,IAAI,GAAGL,EAAK,IAAI,CAAKI,MAAAA,EAAE,CAAC,CAAC,KAAK,GAEtDE,IACF,WAAWD,EAAiB,SAAA,CAAU,EAAE,QAAQJ,CAAS,EAAE,SAAS,GAElEM,KAAWL,IAAYI,KAAU,GACjCE,IAAahB,IAAQe,IAAU,GAC/BE,IAAchB,IAASc,IAAU,GAEjCG,IAASV,EAAK,IAAI,CAACW,MAAY;AACzB,UAAM,IAAKA,EAAQ,IAAIR,IAAoBK,IAAaD,GAClDT,IAAKa,EAAQ,IAAIN,IAAoBI,IAAcF;AAClD,WAAA,GAAG,CAAC,IAAIT,CAAC;AAAA,EAAA,CACnB,EAAE,KAAK,GAAG;AAEZ,SAAA;AAAA,IACH,WAAAI;AAAA,IACA,SAAAK;AAAA,IACA,kBAAAJ;AAAA,IACA,kBAAAE;AAAA,IACA,aAAAI;AAAA,IACA,YAAAD;AAAA,IACA,QAAAE;AAAA,EAAA;AAER;AAQgB,SAAAE,EAAYC,GAAevB,IAAc,GAAW;AACzD,SAAA,KAAK,IAAI,KAAK,IAAI,IAAIuB,IAAQ,OAAOvB,CAAG,IAAI,KAAK,KAAK,GAAG;AACpE;"}