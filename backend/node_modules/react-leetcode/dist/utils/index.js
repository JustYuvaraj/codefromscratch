function p(t) {
  const c = t.split("/");
  return c[c.length - 1];
}
function f(t) {
  if (t.length === 0)
    return [];
  if (t.length === 1)
    return [{
      x: 0,
      y: 0,
      ...t[0]
    }];
  const c = t[0].contest.startTime, i = t[t.length - 1].contest.startTime, [u, e] = t.reduce(
    ([a, r], { rating: n }) => [Math.min(a, n), Math.max(r, n)],
    [1 / 0, -1 / 0]
  ), m = 500, s = 150, h = m / (i - c), o = s / (e - u);
  return t.map((a) => {
    const { rating: r } = a, n = a.contest.startTime, x = Math.round((n - c) * h), l = Math.round((e - r) * o);
    return {
      x,
      y: l,
      ...a
    };
  });
}
function M(t, c, i, u) {
  if (i.length === 0)
    return;
  const e = t / 50, m = Math.max(...i.map((n) => n.x)) || 1, s = Math.max(...i.map((n) => n.y)) || 1, h = parseFloat(s.toString()).toFixed(u).length + 1, o = (e + h) * 2, g = t - o * 2, a = c - o * 2, r = i.map((n) => {
    const x = n.x / m * g + o, l = n.y / s * a + o;
    return `${x},${l}`;
  }).join(" ");
  return {
    FONT_SIZE: e,
    padding: o,
    maximumXFromData: m,
    maximumYFromData: s,
    chartHeight: a,
    chartWidth: g,
    points: r
  };
}
function d(t, c = 8) {
  return Math.sin(Math.min(1, (t + 0.5) / c) * Math.PI * 0.5);
}
export {
  M as LineChartCalculations,
  d as calcOpacity,
  f as getCordinates,
  p as getPath
};
//# sourceMappingURL=index.js.map
